# Manchester Challenge

<p align="justify">
Main project developed in collaboration with Manchester Robotics, as part of the undergraduate courses <strong>"Robotics Foundation"</strong> and <strong>"Intelligent Robotics Implementation."</strong>
</p>

## First Stage: ROS2 DC Motor Control

<p align="justify">
The goal was to control the speed of a DC motor attached to one of the wheels of the Puzzlebot — Manchester Robotics’ educational, differential-drive mobile robot.
</p>

<p align="justify">
Although velocity control for the Puzzlebot’s wheels will later use pre-built facilities provided by Manchester Robotics, it is essential to first understand the core control principles.
</p>

<p align="justify">
One approach is open-loop control, where voltage is applied in proportion to the desired speed. However, this method may not be robust enough, since it lacks self-correction.
</p>

<p align="justify">
For this reason, a closed-loop controller was used: a PID. By applying proportional, integral, and derivative terms, the system can reduce error over time. This ensures that the actual speed converges to the desired value.
</p>

## Methodology

<p align="justify">
Initially, two prototype nodes were created to test ROS2 functionality. The first node generated a sinusoidal signal, and the second acted as a signal processor. It subscribed to the signal generated by the first node, modified it, and published the processed signal. Both signals were visualized using <code>rqt_plot</code>.
</p>

<p align="justify">
To implement this:
</p>

<p align="justify">
1. A ROS2 package named <code>signal_processing</code> was created.<br>
2. Inside this package, the <code>signal_generator</code> node was developed. It used <code>math.sin()</code> and a time variable <code>t</code> that incremented on each callback to compute a sinusoidal wave. The resulting signal was published on the <code>/signal</code> topic.<br>
3. Next, the <code>signal_processor</code> node was implemented. It subscribed to the <code>/signal</code> topic and applied modifications to the incoming signal: a phase shift (using a trigonometric identity), reduced amplitude, and an offset. The processed signal was then published to its own topic <code>/proc_signal</code>.<br>
4. A launch file was added to start both nodes and open <code>rqt_plot</code> for signal visualization.
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/28615f98-54db-4918-b63d-d1fafd96970a" alt="rqt_graph of the signal_processing system" width="600"/>
</p>

<p align="justify">
After building the package, the full system can be launched with:
</p>

```bash
ros2 launch signal_processing signal_processing.launch.py
```

<p align="justify">
The <code>signal_generator</code> node later evolved into the <code>setpoint</code> node for a simulated PID control system. The simulation included three main nodes:
</p>

<p align="justify">
- <code>setpoint</code>: published speed references.<br>
- <code>controller</code>: subscribed to both the setpoint and simulated motor output, computed the error, applied the PID algorithm, and published the control signal.<br>
- <code>dc_motor</code>: simulated motor dynamics using a first-order model, received the control input, updated the speed, and published feedback.
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/433dc63e-382e-4a93-b062-9bd50e7500eb" alt="rqt_graph of the motor_control system" width="600"/>
</p>

<p align="justify">
The code was updated to load node parameters directly from the launch file and to allow real-time tuning using <code>rqt_reconfigure</code>.
</p>

<p align="justify">
The reference node was extended to support both sinusoidal and square wave signals. The signal type can also be changed in real time through dynamic configuration.
</p>

<p align="justify">
A new launch file was created to start three sets of motor controllers. To improve robustness, node execution order was managed using services, following this sequence:
</p>

<p align="justify">
1. <code>dc_motor</code><br>
2. <code>controller</code><br>
3. <code>setpoint</code>
</p>

<p align="justify">
After building the package, the full system can be launched with:
</p>

```bash
ros2 launch motor_control motor_control.launch.py 
```

<p align="justify">
This setup allowed experimentation with PID parameters and performance evaluation before working with real hardware.
</p>

<p align="justify">
In the hardware phase, the <code>setpoint</code> node ran on a PC. The <code>motor</code> node was implemented on an ESP32 microcontroller using microROS. This node handled the full control loop.
</p>

<p align="justify">
The ESP32 used interrupts to read signals from a quadrature encoder and calculate the motor’s angular velocity. The <code>motor</code> node subscribed to the <code>setpoint</code> topic to receive the target speed. It then computed the error between the reference and the measured velocity, applied the PID algorithm to calculate the control output, and converted this into a PWM signal sent to the H-bridge to drive the motor.
</p>

<p align="justify">
To support system monitoring, the <code>motor</code> node also published key data through dedicated topics: the encoder count, measured angular velocity, error value, and the applied control signal.
</p>
