# Manchester Challenge

<p align="justify">
Main project developed in collaboration with Manchester Robotics, as part of the undergraduate courses <strong>"Robotics Foundation"</strong> and <strong>"Intelligent Robotics Implementation."</strong>
</p>

## First Stage: ROS2 DC Motor Control

<p align="justify">
The goal was to control the speed of a DC motor attached to one of the wheels of the Puzzlebot — Manchester Robotics’ educational, differential-drive mobile robot.
</p>

<p align="justify">
Although velocity control for the Puzzlebot’s wheels will later use pre-built facilities provided by Manchester Robotics, it is essential to first understand the core control principles.
</p>

<p align="justify">
One approach is open-loop control, where voltage is applied in proportion to the desired speed. However, this method may not be robust enough, since it lacks self-correction.
</p>

<p align="justify">
For this reason, a closed-loop controller was used: a PID. By applying proportional, integral, and derivative terms, the system can reduce error over time. This ensures that the actual speed converges to the desired value.
</p>

<p align="justify">
ROS 2 was used as the middleware to modularize and standardize the robotics software. In other words, it enables the development of a more organized and maintainable system.
</p>

### Methodology

<p align="justify">
Initially, two prototype nodes were created to test ROS2 functionality. The first node generated a sinusoidal signal, and the second acted as a signal processor. It subscribed to the signal generated by the first node, modified it, and published the processed signal. Both signals were visualized using <code>rqt_plot</code>.
</p>

![signal_processing system](https://github.com/user-attachments/assets/a3c9a370-571c-4d43-af84-e51f3c0f7135)

<p align="justify">
To implement this:
</p>

<p align="justify">
1. A ROS2 package named <code>signal_processing</code> was created.<br>
2. Inside this package, the <code>signal_generator</code> node was developed. It used <code>math.sin()</code> and a time variable <code>t</code> that incremented on each callback to compute a sinusoidal wave. The resulting signal was published on the <code>/signal</code> topic.<br>
3. Next, the <code>signal_processor</code> node was implemented. It subscribed to the <code>/signal</code> topic and applied modifications to the incoming signal: a phase shift (using a trigonometric identity), reduced amplitude, and an offset. The processed signal was then published to its own topic <code>/proc_signal</code>.<br>
4. A launch file was added to start both nodes and open <code>rqt_plot</code> for signal visualization.
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/28615f98-54db-4918-b63d-d1fafd96970a" alt="rqt_graph of the signal_processing system" width="600"/>
</p>

<p align="justify">
After building the package, the full system can be launched with:
</p>

```bash
ros2 launch signal_processing signal_processing.launch.py
```

<p align="justify">
The <code>signal_generator</code> node later evolved into the <code>setpoint</code> node for a simulated PID control system. The simulation included three main nodes:
</p>

<p align="justify">
- <code>setpoint</code>: published speed references.<br>
- <code>controller</code>: subscribed to both the setpoint and simulated motor output, computed the error, applied the PID algorithm, and published the control signal.<br>
- <code>dc_motor</code>: simulated motor dynamics using a first-order model, received the control input, updated the speed, and published feedback.
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/433dc63e-382e-4a93-b062-9bd50e7500eb" alt="rqt_graph of the motor_control system" width="600"/>
</p>

<p align="justify">
The code was updated to load node parameters directly from the launch file and to allow real-time tuning using <code>rqt_reconfigure</code>.
</p>

<p align="justify">
The reference node was extended to support both sinusoidal and square wave signals. The signal type can also be changed in real time through dynamic configuration.
</p>

<p align="justify">
A new launch file was created to start three sets of motor controllers. To improve robustness, node execution order was managed using services, following this sequence:
</p>

<p align="justify">
1. <code>dc_motor</code><br>
2. <code>controller</code><br>
3. <code>setpoint</code>
</p>

<p align="justify">
After building the package, the full system can be launched with:
</p>

```bash
ros2 launch motor_control motor_control.launch.py 
```

<p align="justify">
This setup allowed experimentation with PID parameters and performance evaluation before working with real hardware.
</p>

<p align="justify">
In the hardware phase, the <code>setpoint</code> node ran on a PC. The <code>motor</code> node was implemented on an ESP32 microcontroller using microROS. This node handled the full control loop. You can find the code in the <code>micro_ROS</code> folder.
</p>

<p align="justify">
The ESP32 used interrupts to read signals from a quadrature encoder and calculate the motor’s angular velocity. The <code>motor</code> node subscribed to the <code>setpoint</code> topic to receive the target speed. It then computed the error between the reference and the measured velocity, applied the PID algorithm to calculate the control output, and converted this into a PWM signal sent to the H-bridge to drive the motor.
</p>

<p align="justify">
To support system monitoring, the <code>motor</code> node also published key data through dedicated topics: the encoder count, measured angular velocity, error value, and the applied control signal.
</p>

### Control Strategy

<p align="justify">
Angular velocity is measured using a quadrature encoder mounted on the motor shaft. Hardware interrupts capture changes in the encoder channels. The velocity is computed by counting encoder pulses over a fixed time interval. With a resolution of 12 pulses per motor shaft revolution and a 34:1 gear reduction ratio, the pulses are converted into radians per second at the output shaft. The final value is multiplied by 2 to account for full quadrature decoding.
</p>

<p align="justify">
To improve signal quality, which can be affected by noise, a low-pass filter is applied. This filter reduces high-frequency components—where abrupt changes in the signal appear—without significantly affecting response time. By attenuating these high frequencies and preserving the lower ones, the filtered signal more accurately represents the actual output of the system.
</p>

<p align="justify">
The PID controller is implemented in discrete form. The result is a control output that we feed as a PWM signal into a motor driver. The driver then provides a voltage to the motor, influencing its angular velocity. We measure this new velocity, closing the loop. Depending on the sign of the control signal, the motor driver also adjusts the motor’s direction. The entire system operates in a closed-loop control cycle running at a constant frequency of 50 Hz.
</p>

### ROS2 Tools

<p align="justify">
The <code>setpoint</code> node publishes reference signals using configurable parameters: timer period, amplitude, and frequency. It supports multiple waveform types—such as sine, square, or step—and can either hold a fixed waveform or cycle through several. All parameters can be updated dynamically at runtime.
</p>

<p align="justify">
Quality of Service (QoS) settings were configured to ensure appropriate communication. The <code>setpoint</code> node used the <code>RELIABLE</code> policy to guarantee that reference signals consistently reached the <code>motor</code> node, as these signals are critical for controlling a real-world system and must not be lost. On the other hand, the <code>motor</code> node used the <code>BEST_EFFORT</code> policy for non-critical data, such as debugging messages, where occasional packet loss is acceptable. This choice also helps reduce communication latency.
</p>

<p align="justify">
In addition, a state machine was implemented to establish and maintain the connection with the micro-ROS agent. In case of disconnection, it attempts to reconnect and reinitialize ROS 2 entities.
</p>

### PID Tuning Strategy

<p align="justify">
To tune the PID, a manual approach was used, where gains were adjusted through trial and error until the system responded satisfactorily. This process was not just guesswork; it followed the following general methodology:
</p>

<p align="justify">
The process began with a pure P controller. The proportional gain scales the error, so increasing the P value makes the system reach the setpoint faster. However, if the P gain is too high, it can cause oscillations.
</p>

<p align="justify">
The integral term was then added to eliminate steady-state error, helping the system reach and maintain the desired reference over time.
</p>

<p align="justify">
Finally, the derivative term was introduced. D-action provides damping but is highly sensitive to noise. Rapid changes in the signal generate large derivative values, which can amplify measurement noise. Due to the presence of noise in the setup, the D term was applied conservatively.
</p>

### Sampling Time

<p align="justify">
The sampling time is set to 50 Hz. In theory, a higher sampling frequency allows the controller to respond more effectively, as it receives more frequent updates about the system’s behavior. However, using ROS introduces overhead that is not present in basic microcontroller setups.
</p>

<p align="justify">
In this case, the system is limited by the executor's spin time, which also processes incoming setpoint data from the teleoperator. As a result, the controller cannot operate at a frequency higher than the rate at which new setpoint values can be reliably received.
</p>

### Performance Evaluation

<p align="justify">
As an acceptance criterion, the mean square error (MSE) was calculated to evaluate the overall effectiveness of the controller. For the sine wave input, the MSE remained consistently below 1 throughout the test. In the case of the ramp signal, which features less abrupt variation, the MSE stayed below 0.25 — both indicating low error levels.
</p>

<p align="justify">
Controller robustness can also be assessed by observing its response to different types of input signals and external disturbances.
</p>
